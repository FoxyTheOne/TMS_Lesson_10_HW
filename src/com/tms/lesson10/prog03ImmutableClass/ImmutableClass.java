package com.tms.lesson10.prog03ImmutableClass;

import java.util.Objects;

/**
 * 3. Создать неизменяемы(imnnutable) класс
 *
 * Чтобы сделать класс неизменяемым, следуйте этим пяти правилам:
 * 1) не предоставляйте методы, которые изменяют состояние объекта (известные как мутаторы)
 * 2) убедитесь, что класс не может быть расширен. Это предотвращает небрежное или злонамеренное подклассы от компрометации
 * неизменяемого поведения класса, ведя себя так, как будто состояние объекта изменилось.
 * Предотвращение подклассов обычно достигается путем создания класса final или предоставления частного конструктора
 * 3) Сделайте все поля окончательными. Это четко выражает ваше намерение таким образом, чтобы система выполняла его.
 * Кроме того, необходимо обеспечить правильное поведение, если ссылка на вновь созданный экземпляр передается из одного
 * потока в другой без синхронизации, как указано в модели памяти
 * 4) Сделайте все поля закрытыми. Это не позволяет клиентам получать доступ к изменяемым объектам, на которые ссылаются поля,
 * и изменять эти объекты напрямую. Хотя технически допустимо, чтобы неизменяемые классы имели открытые конечные поля,
 * содержащие примитивные значения или ссылки на неизменяемые объекты, это не рекомендуется, поскольку это исключает изменение
 * внутреннего представления в более позднем выпуске.
 * 5) Обеспечьте исключительный доступ к любым изменяемым компонентам. Если в вашем классе есть какие-либо поля, ссылающиеся
 * на изменяемые объекты, убедитесь, что клиенты класса не могут получить ссылки на эти объекты. Никогда не инициализируйте
 * такое поле ссылкой на объект, предоставленный клиентом, и не возвращайте поле из средства доступа. Сделайте защитные
 * копии (пункт 50) в конструкторах, средствах доступа и методах readObject.
 *
 * !! В классе есть поле String, а это ссылочный тип.
 * Для таких полей правильнее будет передавать копию этого объекта.
 * (для более подробный информации обратите внимание на книгу Блоха, глава 15, раздел классы и интерфейсы)
 */
public final class ImmutableClass { // !! Объявите класс как окончательный (so no sub-classes can be made)

    private final int id; // !! Объявите все поля закрытыми, сделайте все поля окончательными (private and final). Не предоставляйте метод setter для этого частного поля.
    private final String name;

    public ImmutableClass(int id, String name) {
        this.id = id;
        this.name = name;
        // Помните, что массивы ненулевой длины всегда являются изменяемыми. Таким образом, вы всегда должны делать копию внутреннего массива перед его возвратом клиенту.
        // Либо можно вернуть неизменяемое представление массива. Оба эти метода рассматриваются в разделе 4.1
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return new String(name);
    }
    // Ссылочный тип - передаём копию объекта

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ImmutableClass that = (ImmutableClass) o;
        return id == that.id && Objects.equals(name, that.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, name);
    }

}
